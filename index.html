<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitLab Membership Viewer</title>
    <style>
        :root {
            --primary-color: #5b4ee1;
            /* GitLab-ish violet */
            --bg-color: #f9fafb;
            --text-color: #333;
            --border-color: #e5e7eb;
            --header-bg: #fff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: var(--header-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 250px;
        }

        label {
            font-weight: 600;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="password"] {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
        }

        button {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            height: 42px;
            /* Match input height roughly */
        }

        button:hover {
            opacity: 0.9;
        }

        #app {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            padding: 20px;
        }

        /* Matrix Table Styles */
        .matrix-table {
            display: grid;
            /* Grid template columns will be dynamic */
            border-collapse: collapse;
            width: 100%;
            min-width: 800px;
        }

        .header-cell {
            background: #f3f4f6;
            padding: 10px;
            font-weight: bold;
            border-bottom: 2px solid var(--border-color);
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .row-header {
            /* First column (Groups/Projects) */
            position: sticky;
            left: 0;
            background: white;
            z-index: 5;
            border-right: 1px solid var(--border-color);
        }

        .cell {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid #f0f0f0;
            white-space: nowrap;
        }

        .group-row {
            font-weight: 600;
        }

        .project-row {
            color: #555;
        }

        .expand-toggle {
            cursor: pointer;
            display: inline-block;
            width: 20px;
            text-align: center;
            margin-right: 5px;
            user-select: none;
        }

        .indent {
            display: inline-block;
            width: 20px;
        }

        /* Role Colors */
        .role-owner {
            color: #d9534f;
            font-weight: bold;
        }

        .role-maintainer {
            color: #f0ad4e;
            font-weight: bold;
        }

        .role-developer {
            color: #5cb85c;
        }

        .role-reporter {
            color: #5bc0de;
        }

        .role-guest {
            color: #777;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        .error {
            color: red;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <div class="form-group">
                <label for="apiKey">GitLab API Key</label>
                <input type="password" id="apiKey" placeholder="glpat-..." autocomplete="off">
            </div>
            <div class="form-group">
                <label for="groupUrl">Start Group URL</label>
                <input type="text" id="groupUrl" placeholder="https://gitlab.com/my-org/my-group">
            </div>
            <button id="loadBtn">Load Hierarchy</button>
        </header>

        <div id="errorMsg" class="error"></div>

        <div id="app">
            <div class="loading" style="display: none;">Loading...</div>
            <div id="matrixContainer"></div>
        </div>
    </div>

    <script>
        // State
        const state = {
            apiKey: '',
            baseUrl: '',
            rows: [], // { type: 'group'|'project', id, name, full_path, level, expanded, loaded, parentId, hasChildren }
            columns: [], // { id, name, username } - Members
            memberships: {}, // Key: rowId_colId, Value: role (string)
            loading: false
        };

        // DOM Elements
        const els = {
            apiKey: document.getElementById('apiKey'),
            groupUrl: document.getElementById('groupUrl'),
            loadBtn: document.getElementById('loadBtn'),
            errorMsg: document.getElementById('errorMsg'),
            loading: document.querySelector('.loading'),
            matrixContainer: document.getElementById('matrixContainer')
        };

        // Event Listeners
        els.loadBtn.addEventListener('click', initLoad);

        async function initLoad() {
            state.apiKey = els.apiKey.value.trim();
            const groupUrlStr = els.groupUrl.value.trim();

            if (!state.apiKey || !groupUrlStr) {
                showError('Please provide both API Key and Group URL');
                return;
            }

            showError('');
            setLoading(true);

            try {
                // Reset State
                state.rows = [];
                state.columns = [];
                state.memberships = {};

                // 1. Determine Base URL and Group Path
                const { baseUrl, groupPath } = parseGitLabUrl(groupUrlStr);
                state.baseUrl = baseUrl;

                // 2. Fetch Root Group
                const groupData = await fetchGitLab(`groups/${encodeURIComponent(groupPath)}`);

                // 3. Initialize Root Row
                const rootRow = {
                    type: 'group',
                    id: groupData.id,
                    name: groupData.name,
                    full_path: groupData.full_path,
                    level: 0,
                    expanded: false,
                    loaded: false,
                    parentId: null,
                    hasChildren: true // Assume root has children initially or we check later
                };
                state.rows.push(rootRow);

                // 4. Fetch Initial Members (Root Group)
                await fetchAndStoreMembers(rootRow);

                // 5. Render
                renderMatrix();
            } catch (err) {
                showError(err.message);
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        function parseGitLabUrl(urlStr) {
            try {
                const url = new URL(urlStr);
                // Example: https://gitlab.com/my-org/group
                // Base API: https://gitlab.com/api/v4/
                const baseUrl = `${url.origin}/api/v4/`;
                const groupPath = url.pathname.substring(1); // Remove leading /
                return { baseUrl, groupPath };
            } catch (e) {
                throw new Error('Invalid URL format');
            }
        }

        async function fetchGitLab(endpoint) {
            const url = `${state.baseUrl}${endpoint}`;
            const response = await fetch(url, {
                headers: {
                    'PRIVATE-TOKEN': state.apiKey
                }
            });

            if (!response.ok) {
                if (response.status === 401) throw new Error('Unauthorized: Check your API Key');
                if (response.status === 404) throw new Error('Not Found: Check URL or Permissions');
                throw new Error(`API Error: ${response.statusText}`);
            }

            return response.json();
        }

        async function fetchAndStoreMembers(row) {
            const endpoint = row.type === 'group'
                ? `groups/${row.id}/members`
                : `projects/${row.id}/members`;

            const members = await fetchGitLab(endpoint);

            let newColumns = false;
            members.forEach(m => {
                // Add to columns if not exists
                if (!state.columns.find(c => c.id === m.id)) {
                    state.columns.push({
                        id: m.id,
                        name: m.name,
                        username: m.username
                    });
                    newColumns = true;
                }

                // Store Membership
                // AccessLevel is numeric, we might want string representation
                // 10: Guest, 20: Reporter, 30: Developer, 40: Maintainer, 50: Owner
                const roleName = getRoleName(m.access_level);
                state.memberships[`${row.id}_${m.id}`] = roleName;
            });

            if (newColumns) {
                state.columns.sort((a, b) => a.name.localeCompare(b.name));
            }
        }

        function getRoleName(level) {
            const roles = {
                10: 'Guest',
                20: 'Reporter',
                30: 'Developer',
                40: 'Maintainer',
                50: 'Owner'
            };
            return roles[level] || level;
        }

        async function toggleGroup(rowId) {
            const row = state.rows.find(r => r.id === rowId);
            if (!row) return;

            if (row.expanded) {
                // Collapse: Hide children
                row.expanded = false;
                // We don't remove data, just hide in render? 
                // Or we can flag children as hidden. 
                // Simple approach: Render filters visible rows.
                // But we need to recursively collapse or just hide visual children?
                // "Collapse" usually just hides immediate children in tree view.
                renderMatrix();
            } else {
                // Expand
                row.expanded = true;
                if (!row.loaded) {
                    setLoading(true);
                    try {
                        await loadChildren(row);
                        row.loaded = true;
                    } catch (e) {
                        showError(e.message);
                    } finally {
                        setLoading(false);
                    }
                }
                renderMatrix();
            }
        }

        async function loadChildren(parentRow) {
            // Fetch Subgroups
            const subgroups = await fetchGitLab(`groups/${parentRow.id}/subgroups`);
            // Fetch Projects
            const projects = await fetchGitLab(`groups/${parentRow.id}/projects`);

            // Create new row objects
            const newRows = [];

            subgroups.forEach(g => {
                newRows.push({
                    type: 'group',
                    id: g.id,
                    name: g.name,
                    full_path: g.full_path,
                    level: parentRow.level + 1,
                    expanded: false,
                    loaded: false,
                    parentId: parentRow.id,
                    hasChildren: true
                });
            });

            projects.forEach(p => {
                newRows.push({
                    type: 'project',
                    id: p.id,
                    name: p.name,
                    full_path: p.full_path,
                    level: parentRow.level + 1,
                    expanded: false, // Projects don't expand
                    loaded: true, // Nothing to load for projects (except members which we do next)
                    parentId: parentRow.id,
                    hasChildren: false
                });
            });

            // Insert new rows after parent
            const parentIndex = state.rows.findIndex(r => r.id === parentRow.id);
            state.rows.splice(parentIndex + 1, 0, ...newRows);

            // Fetch members for all new rows
            // Parallelize for performance?
            const promises = newRows.map(r => fetchAndStoreMembers(r));
            await Promise.all(promises);
        }

        function getVisibleRows() {
            // Flatten list is already in order.
            // We just need to skip rows whose parents are collapsed.
            const visible = [];
            // We can track "current visibility scope"
            // But simpler: check if all ancestors are expanded.
            // Optimization: Iterate and maintain a "skip until level X" flag?

            // Better: Recursive check or map of expanded IDs.
            // Since it's a flat list in tree order:
            // If a parent is collapsed, skip all its descendants.

            let skipUntilLevel = null;

            for (const row of state.rows) {
                if (skipUntilLevel !== null) {
                    if (row.level > skipUntilLevel) {
                        continue; // Skip descendant
                    } else {
                        skipUntilLevel = null; // End of skipped block
                    }
                }

                visible.push(row);

                if (row.type === 'group' && !row.expanded) {
                    skipUntilLevel = row.level;
                }
            }
            return visible;
        }

        function renderMatrix() {
            const visibleRows = getVisibleRows();
            const totalCols = state.columns.length + 1; // +1 for Row Header

            // Update Grid Template
            // First col auto (or fixed width), others auto
            els.matrixContainer.style.gridTemplateColumns = `300px repeat(${state.columns.length}, minmax(100px, auto))`;

            let html = '<div class="matrix-table" style="grid-template-columns: 300px repeat(' + state.columns.length + ', minmax(100px, 1fr));">';

            // 1. Header Row
            // Top-Left Corner
            html += '<div class="header-cell row-header" style="z-index:20">Hierarchy</div>';
            // Member Columns
            state.columns.forEach(col => {
                html += `<div class="header-cell">${col.name}</div>`;
            });

            // 2. Data Rows
            visibleRows.forEach(row => {
                // Row Header
                const indent = row.level * 20;
                const toggle = row.type === 'group'
                    ? `<span class="expand-toggle" onclick="toggleGroup(${row.id})">${row.expanded ? '[-]' : '[+]'}</span>`
                    : `<span class="indent"></span>`; // Spacer for alignment

                const icon = row.type === 'group' ? 'ðŸ“‚' : 'ðŸ“„';

                html += `<div class="cell row-header" style="padding-left: ${10 + indent}px">
                ${toggle} ${icon} ${row.name}
            </div>`;

                // Member Cells
                state.columns.forEach(col => {
                    const role = state.memberships[`${row.id}_${col.id}`] || '';
                    const roleClass = role ? `role-${role.toLowerCase()}` : '';
                    html += `<div class="cell ${roleClass}">${role}</div>`;
                });
            });

            html += '</div>';
            els.matrixContainer.innerHTML = html;
        }

        function setLoading(isLoading) {
            state.loading = isLoading;
            els.loading.style.display = isLoading ? 'block' : 'none';
            els.loadBtn.disabled = isLoading;
        }

        function showError(msg) {
            els.errorMsg.textContent = msg;
        }

        // Expose to window for onclick
        window.toggleGroup = toggleGroup;

    </script>
</body>

</html>